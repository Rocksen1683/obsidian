## Problem 

![[Pasted image 20240213032917.png]]
![[Pasted image 20240213032945.png]]

## Approach 
Make a map that maps old nodes to new nodes and then do a recursive [[DFS for Graphs]]
The reason for making a map is because for every node, we need to create a new Node as part of our "clone". 

Main Understanding: Use a HashMap to keep track of old versus new because you just can't return old nodes.
## Solution 
```python
def cloneGraph(self, node: Optional['Node']) -> Optional['Node']:
		#returning None if graph empty
        if node is None:
            return None

        #make a map that maps old to new
        cloneMap = {}

        def DFS(n):
            if n in cloneMap:
                return cloneMap[n] #returning clone

            #make a copy as we don't have a copy yet
            copy = Node(n.val)
            cloneMap[n] = copy
            
            for nbr in n.neighbors:
                #adding the cloned neighbors to the copy
                copy.neighbors.append(DFS(nbr))
                
            return copy
       #calling depth first search on main node
        return DFS(node)
```
