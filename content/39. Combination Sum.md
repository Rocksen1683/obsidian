## Problem
https://leetcode.com/problems/combination-sum/description/

## Solution 

``` python 
def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:

	#use depth first search with additional states
	res = []


	def dfs(i, cur, total):
		#base case if we hit target
		if total == target:
			#add current combination to result
			res.append(cur.copy()) #ensure to make copy because you dont wanna change cur
			return

		#if we have gone over then return nothing
		if i>=len(candidates) or total > target:
			return
			
		#branch left which would mean adding current one to to total
		cur.append(candidates[i])
		dfs(i, cur, total + candidates[i])                

		#branch right meaning remove changes made and iterate to next element
		cur.pop()
		dfs(i + 1, cur, total)


	dfs(0, [], 0)
	return res
```